# Camper level + BLE proxy + ISM330DLC external component (ESPHome 2025.12.2)
# - Uses local external component: components/ism330dlc_level
# - BLE Proxy retained
# - Normal vs Leveling Mode:
#     * Leveling Mode ON  -> IMU polls every 500ms, Pitch/Roll publish ~500ms
#     * Leveling Mode OFF -> IMU polls every 3s,   Pitch/Roll publish ~3s
# - Auto-timeout: Leveling Mode turns OFF after 15 minutes

external_components:
  - source:
      type: local
      path: components

esphome:
  name: esphome-web-caf034
  friendly_name: Camper Level + BT Proxy

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: DEBUG
  logs:
    ism330dlc_level: DEBUG

api:

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# Keep BTLE capability
esp32_ble_tracker:
bluetooth_proxy:
  active: true

i2c:
  sda: 23
  scl: 22
  frequency: 50000
  scan: true

# Calibration offsets (degrees)
number:
  - platform: template
    name: "Pitch Offset"
    id: pitch_offset
    min_value: -15
    max_value: 15
    step: 0.1
    restore_value: true
    optimistic: true

  - platform: template
    name: "Roll Offset"
    id: roll_offset
    min_value: -15
    max_value: 15
    step: 0.1
    restore_value: true
    optimistic: true

# Leveling mode + auto-timeout
globals:
  - id: leveling_mode
    type: bool
    restore_value: true
    initial_value: "false"

  # Absolute millis() timestamp when leveling mode should auto-expire (0 = disabled)
  - id: leveling_timeout_ms
    type: uint32_t
    restore_value: false
    initial_value: "0"

switch:
  - platform: template
    name: "Camper Leveling Mode"
    id: leveling_mode_sw
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      return id(leveling_mode);

    turn_on_action:
      - lambda: |-
          id(leveling_mode) = true;

          // Leveling mode rates (ms)
          id(imu).set_update_interval(500);

          // Auto-timeout after 15 minutes
          id(leveling_timeout_ms) = millis() + 15UL * 60UL * 1000UL;

    turn_off_action:
      - lambda: |-
          id(leveling_mode) = false;

          // Normal mode rates (ms)
          id(imu).set_update_interval(3000);

          // Disable timeout
          id(leveling_timeout_ms) = 0;

interval:
  - interval: 5s
    then:
      - lambda: |-
          if (id(leveling_mode) && id(leveling_timeout_ms) != 0) {
            // millis() rollover-safe check
            int32_t remaining = (int32_t)(id(leveling_timeout_ms) - millis());
            if (remaining <= 0) {
              ESP_LOGI("level_mode", "Leveling mode timeout reached, switching to normal mode.");
              id(leveling_mode_sw).turn_off();
            }
          }

sensor:
  # Raw accel from ISM330DLC via external component
  - platform: ism330dlc_level
    id: imu
    address: 0x6A
    accel_x:
      name: "Accel X"
      id: accel_x_g
    accel_y:
      name: "Accel Y"
      id: accel_y_g
    accel_z:
      name: "Accel Z"
      id: accel_z_g
    # Default = normal mode
    update_interval: 3s

  # Pitch (degrees) with mode-based throttling
  - platform: template
    name: "Camper Pitch"
    id: camper_pitch
    unit_of_measurement: "°"
    accuracy_decimals: 1
    update_interval: 500ms
    lambda: |-
      static uint32_t last_pub = 0;
      const uint32_t now = millis();

      // In normal mode, publish at most every 3000ms
      if (!id(leveling_mode) && (now - last_pub) < 3000) {
        return {};
      }

      float ax = id(accel_x_g).state;
      float ay = id(accel_y_g).state;
      float az = id(accel_z_g).state;
      if (isnan(ax) || isnan(ay) || isnan(az)) return {};

      float pitch = atan2f(ax, sqrtf(ay*ay + az*az)) * 180.0f / M_PI;
      last_pub = now;
      return pitch + id(pitch_offset).state;

  # Roll (degrees) with mode-based throttling
  - platform: template
    name: "Camper Roll"
    id: camper_roll
    unit_of_measurement: "°"
    accuracy_decimals: 1
    update_interval: 500ms
    lambda: |-
      static uint32_t last_pub = 0;
      const uint32_t now = millis();

      // In normal mode, publish at most every 3000ms
      if (!id(leveling_mode) && (now - last_pub) < 3000) {
        return {};
      }

      float ax = id(accel_x_g).state;
      float ay = id(accel_y_g).state;
      float az = id(accel_z_g).state;
      if (isnan(ax) || isnan(ay) || isnan(az)) return {};

      float roll = atan2f(ay, sqrtf(ax*ax + az*az)) * 180.0f / M_PI;
      last_pub = now;
      return roll + id(roll_offset).state;

binary_sensor:
  - platform: template
    name: "Camper Level OK"
    lambda: |-
      const float tol = 1.0; // degrees
      return (fabs(id(camper_pitch).state) <= tol) && (fabs(id(camper_roll).state) <= tol);
